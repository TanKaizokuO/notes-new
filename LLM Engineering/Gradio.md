---
tags:
  - main
created: 2026-01-31
---
---
## 1. What is Gradio?
[Gradio](https://www.gradio.app/guides/quickstart) is a Python library that allows you to build web UIs for Python functions in minutes. It acts as a thin web layer over your code, converting Python functions into browser-based user interfaces.

> [!INFO] Mental Model
> 
> **Python Function** $\rightarrow$ **Gradio** $\rightarrow$ **Browser UI**
> 
> Effectively: `UI -> Python Function -> UI`

**Why use it?**

- ML Model Demos (Hugging Face standard)    
- Internal Tools & Dashboards
- Rapid Prototyping
- APIs + Frontends in a single file

---

## 2. Installation

Using `uv` (or standard pip):

```bash
# Project root
uv add gradio

# Or inside existing environment
uv pip install gradio
```

**Verify:**

```bash
python -c "import gradio as gr; print(gr.__version__)"
```

---

## 3. Core Concepts: The `Interface` Class

The quickest way to start. You map a function (`fn`) to UI widgets (`inputs` and `outputs`).

### Basic Hello World

```python
import gradio as gr

def greet(name: str) -> str:
    return f"Hello, {name}!"

# UI Logic
demo = gr.Interface(
    fn=greet,
    inputs=gr.Textbox(label="Your name"),
    outputs=gr.Textbox(label="Greeting"),
    flagging_mode="never"
)

if __name__ == "__main__":
    demo.launch()
```

_Run with:_ `python app.py` $\rightarrow$ Open `http://127.0.0.1:7860`

### Interface Configuration Tips

You can customize how the app launches and looks:

**1. Auto-open Browser & Auth**

```python
# 'inbrowser' opens a new tab automatically
# 'auth' adds a basic login popup
demo.launch(inbrowser=True, auth=("admin", "password123"))
```

**2. Force Dark Mode (via JS)**

```python
force_dark_mode = """
function refresh() {
    const url = new URL(window.location);
    if (url.searchParams.get('__theme') !== 'dark') {
        url.searchParams.set('__theme', 'dark');
        window.location.href = url.href;
    }
}
"""
gr.Interface(fn=greet, inputs="text", outputs="text", js=force_dark_mode).launch()
```

---

## 4. Working with LLMs (Streaming)

Gradio is excellent for Text-to-Text generation because it supports **streaming** (sending partial results back to the UI).

> [!NOTE] The Generator Pattern
> 
> To stream results, your Python function should use `yield` instead of `return`.

**Example: Streaming GPT-4 Response**

```python
import gradio as gr
import openai

def stream_gpt(prompt):
    messages = [
        {"role": "system", "content": "You are a helpful assistant."},
        {"role": "user", "content": prompt}
    ]
    
    stream = openai.chat.completions.create(
        model='gpt-4o-mini',
        messages=messages,
        stream=True
    )
    
    result = ""
    for chunk in stream:
        # Append new content to the running result
        result += chunk.choices[0].delta.content or ""
        # Yield the updated full text to the UI
        yield result 
    # or we can use "yield from result"

# UI Setup
view = gr.Interface(
    fn=stream_gpt,
    title="GPT Streamer",
    inputs=[gr.Textbox(label="Message", lines=5)],
    outputs=[gr.Markdown(label="Response")], # Markdown renders rich text
    flagging_mode="never"
)

view.launch()
```

---

## 5. Advanced Layouts: `Blocks`

While `Interface` is fast, **`Blocks`** offers control over layout and event flows (reactive programming).

> [!NOTE] Key Idea
> 
> In Blocks, you explicitly wire events using `component.click(fn, inputs, outputs)`.


```python
import gradio as gr

def reverse(text):
    return text[::-1]

with gr.Blocks() as demo:
    gr.Markdown("# String Tools")
    
    with gr.Row():
        inp = gr.Textbox(label="Input")
        out = gr.Textbox(label="Output")
    
    btn = gr.Button("Reverse")
    
    # Event Listener
    btn.click(fn=reverse, inputs=inp, outputs=out)

demo.launch()
```

---

## 6. State Management

Gradio is stateless by default. To persist data across user interactions (within the same session), use `gr.State`.

```python
def increment(count):
    return count + 1

with gr.Blocks() as demo:
    state = gr.State(0) # Hidden state storage
    out = gr.Number()
    btn = gr.Button("Add 1")
    
    # Input state, Output new state AND display
    btn.click(increment, state, [state, out]) 
```

---

## 7. Architecture & Mechanics

**How it works (Under the hood):**

1. **Server:** Gradio spins up a **FastAPI** instance.
2. **Serialization:** Inputs (Images, Audio, Text) are serialized to JSON/Base64 before hitting your function.
3. **Queue:** If enabled (`demo.queue()`), an async job queue manages concurrency and prevents server overload.
4. **Frontend:** A React-based UI that renders based on a JSON schema generated by your Python code.

---

## 8. Best Practices

### Project Structure

Keep logic separate from UI code.

```
project/
├── app.py              # UI Definitions
├── services/
│   └── model.py        # Pure Python Logic
└── utils/
    └── preprocess.py
```

### Performance

- **Global Loading:** Load heavy ML models _outside_ the function scope so they load only once.
- **Queues:** Always use `demo.queue()` for heavy workloads or streaming.
- **Caching:** Use `@lru_cache` for static calculations.

### Sharing

- **Public Link:** `demo.launch(share=True)` (Creates a 72-hour proxy tunnel).
- **Notebooks:** `demo.launch(inline=True)`.

---

## 9. When to use Gradio?

|**Use Gradio For ✅**|**Avoid Gradio For ❌**|
|---|---|
|Rapid ML Demos|Large consumer apps|
|Internal Tools|Complex Auth flows|
|Prototyping|Highly custom UI designs|
|Streaming LLM Apps|Mobile-native requirements|

---

For More Details : [[Gradio Working]]